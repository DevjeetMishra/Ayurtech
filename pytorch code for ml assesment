import torch
import torch.nn as nn
import torch.optim as optim
from pymongo import MongoClient
import numpy as np

# Define the updated AI model
class AyurvedicRecommenderWithAdvice(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(AyurvedicRecommenderWithAdvice, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, output_size)  # Output: scores for each product

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Fetch products from MongoDB
def fetch_products_from_db():
    client = MongoClient('mongodb://localhost:27017/')  # Adjust if using cloud
    db = client['ayurvedic_diet_db']
    collection = db['nutrient_data']
    products = list(collection.find())
    client.close()
    return products

# Generate diet sheet and patient advice
def generate_diet_sheet_and_advice(products, scores, threshold=0.5):
    diet_sheet = []
    advice_list = []

    for i, product in enumerate(products):
        score = scores[i]
        if score > threshold:
            quantity = f"{int(score * 100)}g daily"
            advice_list.append(f"Take {quantity} of {product['product_name']} daily to address your deficiencies.")
        else:
            quantity = "Optional"

        diet_sheet.append({
            "product": product['product_name'],
            "recommended_quantity": quantity,
            "nutrients": product['nutrients'],
            "ayurvedic_properties": product['ayurvedic_properties'],
            "score": score
        })

    advice_text = "\n".join(advice_list) if advice_list else "No strong recommendations based on current deficiencies. Consult a practitioner."
    return diet_sheet, advice_text

# Main execution
if __name__ == "__main__":
    # Fetch products (assumes database is populated)
    products = fetch_products_from_db()
    num_products = len(products)
    if num_products == 0:
        print("No products found in the database. Please insert data first.")
        exit()

    # Model setup (input: 6 deficiencies, e.g., calories, protein, vitamin C, iron, calcium, fat)
    input_size = 6
    hidden_size = 16
    model = AyurvedicRecommenderWithAdvice(input_size, hidden_size, num_products)

    # Dummy training (replace with real data; trains to recommend based on inputs)
    train_inputs = torch.tensor([[0.2, 0.3, 0.1, 0.8, 0.4, 0.5]], dtype=torch.float32)
    train_outputs = torch.tensor([[0.7] * num_products], dtype=torch.float32)  # Example targets
    optimizer = optim.Adam(model.parameters(), lr=0.01)
    criterion = nn.MSELoss()

    for epoch in range(10):  # Short training loop for demo
        optimizer.zero_grad()
        predictions = model(train_inputs)
        loss = criterion(predictions, train_outputs)
        loss.backward()
        optimizer.step()
        print(f"Epoch {epoch+1}: Loss = {loss.item():.4f}")

    # Example patient deficiencies (customize this array)
    example_deficiency = torch.tensor([[0.6, 0.1, 0.3, 0.7, 0.2, 0.4]], dtype=torch.float32)

    # Inference
    model.eval()
    with torch.no_grad():
        scores = model(example_deficiency).squeeze().numpy()

    # Normalize scores (0-1)
    scores_norm = (scores - scores.min()) / (scores.max() - scores.min())

    # Generate outputs
    diet_sheet, advice = generate_diet_sheet_and_advice(products, scores_norm)

    print("\nUpdated Diet Sheet:")
    for item in diet_sheet:
        print(f"- {item['product']}: {item['recommended_quantity']}")
        print(f"  Nutrients: {item['nutrients']}")
        print(f"  Ayurvedic Properties: {item['ayurvedic_properties']}")
        print(f"  Score: {item['score']:.2f}\n")

    print("\nPatient Advice on Ayurvedic Products:")
    print(advice)


